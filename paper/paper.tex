\documentclass[sigconf]{acmart}
\acmConference{Bachelor Seminar}{Moderne Hardware}{SS 2025}

\usepackage{minted}

\AtBeginDocument{%
    \providecommand\BibTeX{{%
    Bib\TeX}}
}

\settopmatter{
    printacmref=false,
    printccs=false,
    printfolios=false
}
\renewcommand\footnotetextcopyrightpermission[1]{}

\begin{document}

\title{Implementation of a RISC-V VM in Python}

\author{Elias Oelschner}
\email{elias.oelschner@uni-duesseldorf.de}
\affiliation{%
    \institution{Heinrich Heine University}
    \city{Düsseldorf}
    \state{North Rhine-Westphalia}
    \country{Germany}
}

\renewcommand{\shortauthors}{Oelschner}

\begin{abstract}
In this paper, I present a minimal yet extensible implementation of a RISC-V virtual machine (VM) written in Python. The VM cleanly separates state representation (register file, memory, program counter, halt semantics), instruction decoding and execution semantics encapsulated per instruction. The design prioritizes readability over performance. I demonstrate the VM by executing a hand-written Fibonacci program assembled to machine code.
\end{abstract}

\maketitle

\section{Introduction}
RISC-V has rapidly evolved from a research architecture into a widely adopted open instruction set architecture (ISA) spanning from microcontrollers to larger systems \cite{riscv-spec}. Its fully open specification, modular extension scheme, and avoidance of legacy constraints make it attractive in a variety of contexts, including education, research, and industry.

In this work, I describe a minimal implementation of an interpreter / virtual machine (VM) for the RV32I base ISA written in Python. Python is chosen for its simplicity. The goals are correctness at the architectural level and a modular structure that makes adding new instructions or extensions easy.

The complete source code is available at: \url{https://github.com/levno-710/rvpy}

\section{RISC-V}
As described in the \textit{RISC-V Instruction Set Manual}~\cite{riscv-spec}, RISC-V is a free, open instruction set architecture (ISA) that is designed to be simple and extensible.
It was developed at the University of California, Berkeley, and was originally intended for use in academic research and education. In recent years, it has gained popularity in the industry as a viable alternative to proprietary ISAs like x86 and ARM.
The following goals of RISC-V are quoted directly from the \textit{RISC-V Instruction Set Manual}~\cite{riscv-spec}:
\begin{itemize}
    \item "A completely \emph{open} ISA that is freely available to academia and industry." \cite{riscv-spec}
    \item "A \emph{real} ISA suitable for direct native hardware implementation, not just simulation or binary translation." \cite{riscv-spec}
    \item "An ISA that avoids 'over-architecting' for a particular microarchitecture style." \cite{riscv-spec}
    \item "An ISA separated into a small base integer ISA, usable by itself as a base for customized accelerators or for educational purposes, and optional standard extensions, to support general-purpose software development." \cite{riscv-spec}
    \item "Support for the revised 2008 IEEE-754 floating-point standard." \cite{riscv-spec}
    \item "An ISA supporting extensive ISA extensions and specialized variants." \cite{riscv-spec}
    \item "Both 32-bit and 64-bit address space variants for applications, operating system kernels, and hardware implementations." \cite{riscv-spec}
    \item "An ISA with support for highly parallel multicore or manycore implementations, including heterogeneous multiprocessors." \cite{riscv-spec}
    \item "A fully virtualizable ISA to ease hypervisor development." \cite{riscv-spec}
    \item "An ISA that simplifies experiments with new privileged architecture designs." \cite{riscv-spec}
\end{itemize}
The RISC-V ISA does not define any implementation details, but rather only focuses on the instruction set itself. This allows for a wide range of implementations, from educational simulators to high-performance hardware implementations. \cite{riscv-spec}

\subsection{History}
RISC-V was developed in 2010 at the University of California, Berkeley. The project was led by Andrew Waterman, Krste Asanović, and David Patterson.
In his dissertation, \textit{Design of the RISC-V Instruction Set Architecture}~\cite{waterman2016risc}, Andrew Waterman describes the reasons for the development of RISC-V and its design goals in more detail.
He outlines the key reasons for the development of RISC-V:
\begin{enumerate}
    \item All dominant ISAs were proprietary, which made it difficult for academic and open-source communities to share or commercialize research. This restricted innovation and increased microprocessor costs.
    \item Other popular ISAs were unnecessarily complex, due to legacy design decision and the need to maintain backward compatibility.
    \item Most ISAs were not designed with extensibility in mind, making the addition of new features, such as 64-bit addressing, compressed instructions or virtualization, difficult.
\end{enumerate}
Waterman argues that RISC-V adresses these issues by providing a simple, open, and extensible ISA that is suitable for both academic research and commercial use. He also emphasizes the importance of a clean-slate design that avoids legacy issues and allows for future extensions. \cite{waterman2016risc}

\subsection{Modular Design}\label{sec:modular-design}
RISC-V is designed to be modular, with a small base instruction set that can be extended with optional extensions.
There are several base instruction sets defined, including \textit{RV32I} for 32-bit integer operations and \textit{RV64I} for 64-bit integer operations.
These base instruction sets only include very basic integer operations, such as addition, subtraction, and logical operations as well as control flow instructions like branches and jumps.
RISC-V provides a number of standard extensions that can be added to the base instruction set to support additional functionality. These extensions are designed to be optional, allowing implementers to choose which ones to include based on their specific needs. The \textit{RISC-V Instruction Set Manual}~\cite{riscv-spec} lists the following standard extensions:
\begin{itemize}
    \item \textit{M} for integer multiplication and division.
    \item \textit{A} for atomic memory operations.
    \item \textit{F} for single-precision floating-point.
    \item \textit{D} for double-precision floating-point.
    \item \textit{B} for bit manipulation instructions.
    \item \textit{C} for compressed instructions.
    \item \textit{Zicsr} for control and status register instructions.
    \item \textit{Zifencei} for instruction fetch fence.
    \item Several other optional extensions, such as \textit{V} for vector operations, or \textit{Q} for quad-precision floating-point.
\end{itemize}
Most real world applications will require a combination of these extensions, as the base instruction set is very limited in functionality.
For example, running a modern operating system like Ubuntu Linux requires all of the extensions listed above.

\section{RV32I}
This paper will focus on the \textit{RV32I} base instruction set, which is the most simple form of RISC-V.

\subsection{Registers}
RISC-V uses 32 registers, each 32 bits wide, which are used to store data and addresses. The registers are named \texttt{x0} to \texttt{x31}. Writes to \texttt{x0} are ignored, and reads from \texttt{x0} always return zero. The other registers are used for general-purpose computations.
There also is a special register \textit{pc} (program counter) that holds the address of the next instruction to be executed. The \textit{RV32I} base instruction set does not define any special-purpose registers, but extensions may add additional registers. \cite{riscv-spec}


\subsection{Instruction Set}
The following sections, describe the instructions of the \textit{RV32I} base instruction set in more detail.

\subsection{Integer Register-immediate Instructions}
The integer register-immediate instructions are used to perform operations on registers and immediate values. They are encoded as I-Type instructions and include the following operations:
\begin{itemize}
    \item \texttt{ADDI}: Add immediate value to register
    \item \texttt{SLTI}: Set less than immediate
    \item \texttt{SLTIU}: Set less than immediate unsigned
    \item \texttt{ANDI}: AND immediate
    \item \texttt{ORI}: OR immediate
    \item \texttt{XORI}: Exclusive OR immediate
\end{itemize}
There are also several instructions that perform immediate shifts on registers. These instructions are encoded as R-Type instructions and include the following operations:
\begin{itemize}
    \item \texttt{SLLI}: Shift left logical immediate
    \item \texttt{SRLI}: Shift right logical immediate
    \item \texttt{SRAI}: Shift right arithmetic immediate
\end{itemize}
The last instruction in this category is the \texttt{LUI} instruction, which loads an immediate value into the upper 20 bits of a register and sets the lower 12 bits to zero. This instruction is encoded as a U-Type instruction.
There is also another variant of the \texttt{LUI} instruction, called \texttt{AUIPC}, which adds the immediate value to the current program counter and stores the result in a register. This instruction is also encoded as a U-Type instruction. \cite{riscv-spec}

\subsection{Integer Register-Register Instructions}
All integer register-register instructions are encoded as R-Type instructions and operate on two registers, producing a result in a third register. The following operations are defined:
\begin{itemize}
    \item \texttt{ADD}: Add two registers
    \item \texttt{SUB}: Subtract two registers
    \item \texttt{SLT}: Set less than
    \item \texttt{SLTU}: Set less than unsigned
    \item \texttt{AND}: AND two registers
    \item \texttt{OR}: OR two registers
    \item \texttt{XOR}: Exclusive OR two registers
    \item \texttt{SLL}: Shift left logical
    \item \texttt{SRL}: Shift right logical
    \item \texttt{SRA}: Shift right arithmetic
\end{itemize}
These instructions allow for basic arithmetic and logical operations on registers, as well as shifts. \cite{riscv-spec}

\subsection{Jump Instructions}
Jump instructions are used to change the flow of execution in a program. They are encoded as J-Type instructions.
The following jump instructions are defined:
\begin{itemize}
    \item \texttt{JAL}: Jump and link. This instruction jumps to a target address and saves the return address in a register.
    \item \texttt{JALR}: Jump and link register. This instruction jumps to an address stored in a register and saves the return address in a register.
\end{itemize}
\cite{riscv-spec}

\subsection{Branch Instructions}
Branch instructions are used to conditionally change the flow of execution based on the result of a comparison. They are encoded as B-Type instructions.
The following branch instructions are defined:
\begin{itemize}
    \item \texttt{BEQ}: Branch if equal
    \item \texttt{BNE}: Branch if not equal
    \item \texttt{BLT}: Branch if less than
    \item \texttt{BGE}: Branch if greater than or equal
    \item \texttt{BLTU}: Branch if less than unsigned
    \item \texttt{BGEU}: Branch if greater than or equal unsigned
\end{itemize}
\cite{riscv-spec}

\subsection{Load and Store Instructions}
Load and store instructions are used to access memory. They are encoded as I-Type or S-Type instructions, depending on whether they load data from memory into a register or store data from a register into memory.
The following load instructions are defined:
\begin{itemize}
    \item \texttt{LB}: Load byte
    \item \texttt{LH}: Load halfword
    \item \texttt{LW}: Load word
    \item \texttt{LBU}: Load byte unsigned
    \item \texttt{LHU}: Load halfword unsigned
\end{itemize}
The following store instructions are defined:
\begin{itemize}
    \item \texttt{SB}: Store byte
    \item \texttt{SH}: Store halfword
    \item \texttt{SW}: Store word
\end{itemize}
\cite{riscv-spec}

\subsection{Additional Instructions}
There are 3 additional instructions that are not part of the previous categories:
The \texttt{FENCE} instruction is used to ensure that all previous memory accesses are completed before any subsequent memory accesses. For the purpose of this paper, it can be ignored, as it is not relevant for the implementation of a RISC-V VM.
The \texttt{ECALL} instruction is used to make a system call. The implementation section will  further explain how this instruction is handled in the RISC-V VM.
The \texttt{EBREAK} instruction is used to trigger a breakpoint exception, which can be used for debugging purposes. It is not relevant for the implementation of a RISC-V VM, but it is worth mentioning.


\subsection{Instruction Format}
Instructions in RISC-V are 32 bits wide and encoded in six formats:
\begin{itemize}
  \item \textbf{R-Type}: register-register operations.
  \item \textbf{I-Type}: immediate operations and loads.
  \item \textbf{S-Type}: store instructions.
  \item \textbf{B-Type}: conditional branches.
  \item \textbf{U-Type}: upper immediate instructions.
  \item \textbf{J-Type}: jump instructions.
\end{itemize}
%
\textbf{R-Type:} \\
The R-Type instruction format is used for register-register operations. It includes fields for the opcode, a 3-bit function code (funct3), a 7-bit function code (funct7), and three register fields: rd (destination register), rs1 (source register 1), and rs2 (source register 2). \\
\textbf{Example:} \texttt{add x1, x0, x2} would be encoded as follows:
\begin{verbatim}
0000000 00010 00000 000     00001 0110011
^funct7 ^rs2  ^rs1  ^funct3 ^rd   ^opcode
\end{verbatim}\medskip
%
\textbf{I-Type:} \\
The I-Type instruction format is used for immediate and load operations. It includes fields for a 12-bit immediate \texttt{imm[11:0]}, a 3-bit function code (funct3), register fields \texttt{rs1} and \texttt{rd}, and the opcode. \\
\textbf{Example:} \texttt{addi x1, x2, 10} would be encoded as follows:
\begin{verbatim}
000000000010 00010 000     00001 0010011
^imm[11:0]   ^rs1  ^funct3 ^rd   ^opcode
\end{verbatim}\medskip
Here the bits of the immediate value are used in the same order as they appear in the instruction. The notation \texttt{imm[11:0]} refers to the 12 bits of the immediate value, with \texttt{imm[11]} being the most significant bit and \texttt{imm[0]} being the least significant bit. \\
\medskip
%
\textbf{S-Type:} \\
The S-Type format is used for store instructions. It splits the 12-bit immediate into \texttt{imm[11:5]} and \texttt{imm[4:0]}, with fields: \texttt{imm[11:5]}, \texttt{rs2}, \texttt{rs1}, \texttt{funct3}, \texttt{imm[4:0]}, and \texttt{opcode}. \\
\textbf{Example:} \texttt{sw x2, 4(x1)} would be encoded as follows:
\begin{verbatim}
0000000    00010 00001 010     00100     0100011
^imm[11:5] ^rs2  ^rs1  ^funct3 ^imm[4:0] ^opcode
\end{verbatim}\medskip
Here, the immediate value is stored in a more complex way compared to the I-Type format. The \texttt{imm[11:5]} field is used for the upper 7 bits of the immediate value, while the \texttt{imm[4:0]} field is used for the lower 5 bits. The reason for this is, to have more overlap with other instruction formats: The \texttt{rs2} field is located in the same location as it is in the R-Type format. \\
%
\textbf{B-Type:} \\
The B-Type format is used for conditional branches. The 12-bit immediate is split into \texttt{imm[12|10:5]} and \texttt{imm[4:1|11]}, with fields: \texttt{imm[12|10:5]}, \texttt{rs2}, \texttt{rs1}, \texttt{funct3}, \texttt{imm[4:1|11]}, and \texttt{opcode}. \\
\textbf{Example:} \texttt{beq x1, x2, 8} would be encoded as follows:
\begin{verbatim}
0000000       00010 00001 000     01000        1100011
^imm[12|10:5] ^rs2  ^rs1  ^funct3 ^imm[4:1|11] ^opcode
\end{verbatim}\medskip
The B-Type instruction format stores its immediate value using a modified version of the S-Type layout. Since RISC-V requires all branch targets to be aligned on 2-byte boundaries, the immediate value is always even, meaning its least significant bit (bit 0) is guaranteed to be zero. The B-Type format omits it and uses that bit position for other immediate bits. This omission allows the immediate value to effectively represent one additional bit of range. The immediate bits are rearranged within the instruction as follows: bit 11 of the immediate value is placed where the least significant bit would normally be stored, while the most significant bit (bit 12) is positioned in the same location used by I-Type instructions. This placement of the sign bit matches the I-Type format. \cite{riscv-spec} \\
%
\textbf{U-Type:} \\
The U-Type format is used for upper immediate instructions. It places a 20-bit immediate in bits 31:12, followed by \texttt{rd} and \texttt{opcode}. \\
\textbf{Example:} \texttt{lui x1, 0x12345} would be encoded as follows:
\begin{verbatim}
00010010001101000101 00001 0110111
^imm[31:12]          ^rd   ^opcode
\end{verbatim}\medskip
The immediate value occupies bits [31:12] of the instruction, corresponding to bits [31:12] of the target register when loaded. The lower 12 bits are implicitly set to zero, effectively allowing the immediate to represent values that are multiples of 4096. \cite{riscv-spec} \\
%
\textbf{J-Type:} \\
The J-Type format is used for jump instructions. The 20-bit immediate is split into \texttt{imm[20|10:1|11|19:12]}, followed by \texttt{rd} and \texttt{opcode}. \\
\textbf{Example:} \texttt{jal x1, 16} would be encoded as follows:
\begin{verbatim}
0 00000000 00010000    00001  1101111
^imm[20|10:1|11|19:12] ^rd    ^opcode
\end{verbatim}
The J-Type instruction format stores its immediate value using a layout optimized for jump instructions. Like B-Type, it omits the least significant bit since jump targets must be 2-byte aligned, providing 21 bits of range in a 20-bit field. The immediate bits are scrambled within the instruction: bits [20:1] of the target offset are stored as bits [31], [19:12], [20], and [30:21] respectively. This unconventional arrangement places the sign bit (bit 20) in the instruction's most significant position while grouping related immediate segments together for efficient hardware decoding.
\cite{riscv-spec}

\section{VM Implementation}
In this section, the implementation of a RISC-V VM in Python is described. The VM is designed to execute simple RISC-V programs and is implemented in a modular way, allowing for easy extension and modification.
For fixed integer types, the numpy library is used:
\begin{minted}{python}
import numpy as np
u32 = np.uint32
i32 = np.int32
u8  = np.uint8
i8  = np.int8
\end{minted}

\subsection{State}
The state of the VM is defined in the \texttt{RVState} class. The state consists of the following components:
\begin{itemize}
    \item \texttt{mem}: A numpy array of u8 (unsigned 8-bit integers) that represents the memory of the VM. The size of the memory is not fixed, but can be set to a desired value when creating the VM instance.
    \item \texttt{rf}: A list of 32 registers, each 32 bits wide, initialized to zero.
    \item \texttt{pc}: The 32-bit program counter, initialized to zero.
    \item \texttt{halt}: A boolean flag that indicates whether the VM is halted or not. It is initialized to \texttt{False}.
\end{itemize}

\begin{minted}{python}
class RVState:
    mem:  np.ndarray[u8]  # Memory
    rf:   np.ndarray[i32] # Register file
    pc:   u32             # Program counter
    halt: bool           # Halt flag

    def __init__(self, mem_size: int) -> None:
        self.mem = np.zeros(mem_size, dtype=u8)
        self.rf = np.zeros(32, dtype=i32)
        self.pc = u32(0)
        self.halt = False
\end{minted}
For further details, see \texttt{src/state.py}.

\subsection{VM Execution Loop}
The execution loop of the VM performs the following steps:
\begin{enumerate}
    \item Fetch the next instruction from memory at the current program counter.
    \item Decode the instruction into an \texttt{Instruction} object.
    \item Match the instruction against all available implementations.
    \item If a match is found, execute the instruction using the matched implementation.
    \item If no match is found, raise an exception.
    \item Repeat until the VM is halted.
\end{enumerate}
Each of these steps will be described in detail in the following subsections.

\subsection{Instruction Decoding}
The VM fetches instructions from memory as raw 32-bit words. The raw word is stored and all decoded components are exposed via Python \texttt{@property} accessors.

\begin{minted}{python}
from nums import u32, u8, i32

class Instruction:
    def __init__(self, instruction_word: u32) -> None:
        self.instruction_word = instruction_word

    @property
    def opcode(self) -> u8:
        return u8(self.instruction_word & 0x7F)

    @property
    def funct3(self) -> u8:
        return u8((self.instruction_word >> 12) & 0x07)

    @property
    def funct7(self) -> u8:
        return u8((self.instruction_word >> 25) & 0x7F)

    @property
    def rd(self) -> u8:
        return u8((self.instruction_word >> 7) & 0x1F)

    # ... analogous properties for other fields
\end{minted}

\paragraph{Register / function fields} Extraction of \texttt{rd}, \texttt{rs1}, \texttt{rs2}, \texttt{funct3} and \texttt{funct7} (plus \texttt{opcode}) is a straightforward fixed-bit slicing using masks and shifts corresponding exactly to the layouts shown in the ISA manual. \cite{riscv-spec}

\paragraph{Immediate Value Decoding} The instruction class implements all five immediate formats, each with distinct bit arrangements and sign extension requirements:

\begin{minted}{python}
@property
def imm_i(self) -> i32:
    imm = i32(self.instruction_word >> 20) & 0xFFF
    if imm & 0x800:  # Check sign bit
        imm |= ~0xFFF  # Sign extend
    return imm
\end{minted}

The class deliberately omits any execution semantics; it is a pure decoder / view over the 32-bit word. Execution logic remains in instruction implementation classes described in the following section:

\subsection{Instruction Matching}\label{sec:instruction-matching}
The instructions need to be matched against their respective implementations. To do this, an abstract base class \texttt{InstructionImpl} is used, which defines the interface for all instruction implementations.
\begin{minted}{python}
class InstructionImpl(ABC):
    @abstractmethod
    def match(self, instruction: Instruction) -> bool:
        pass
    @abstractmethod
    def execute(
        self, 
        state: RVState, 
        instruction: Instruction
    ) -> None:
        pass
\end{minted}
The \texttt{match} method is used to check wether the instruction matches the implementation. Typically this is done by checking the opcode and function fields of the instruction.
Each \texttt{Instruction} that is executed will be matched against all implementations. 
If a match is found, the \texttt{execute} method is called with the current state and the instruction. Otherwise, an exception is raised.

\subsection{Instruction Implementation}\label{sec:instruction-implementation}
The next step is to implement the individual instructions. Each instruction is implemented as a subclass of \texttt{InstructionImpl}.
For example, the \texttt{ADD} instruction can be implemented as follows:
\begin{minted}{python}
class Add(InstructionImpl):
    def match(self, instruction: Instruction) -> bool:
        return instruction.opcode == 0b0110011 \
           and instruction.funct3 == 0b000     \
           and instruction.funct7 == 0b0000000
    
    def execute(self, state: RVState, instruction: 
    Instruction) -> None:
        # Extract the source and destination 
        # registers from the instruction
        rd = instruction.rd
        rs1 = instruction.rs1
        rs2 = instruction.rs2

        # Execute the addition
        state.rf[rd] = state.rf[rs1] + state.rf[rs2]

        # Increment the program counter
        state.pc += 4
\end{minted}
The \texttt{match} method checks if the opcode and function fields of the instruction match the \texttt{ADD} instruction as defined in the \textit{RISC-V Instruction Set Manual}~\cite{riscv-spec}.
The \texttt{execute} method extracts the source and destination registers from the instruction and performs the addition. It then updates the destination register with the result and increments the program counter by 4, as each instruction is 4 bytes wide.

\subsection{More Instruction Examples}
While the \texttt{ADD} instruction demonstrates the basic implementation pattern, different instruction categories require specialized handling for their unique semantics. The following examples illustrate how the abstract \texttt{InstructionImpl} interface accommodates the diverse requirements of the RV32I instruction set.

\paragraph{Arithmetic Operations}
Register-register arithmetic operations follow a consistent pattern of extracting operands, performing the operation, storing the result, and advancing the program counter. The \texttt{SUB} instruction demonstrates this pattern:

\begin{minted}{python}
class Sub(InstructionImpl):
    def match(self, instruction: Instruction) -> bool:
        return instruction.opcode == 0b0110011 \
           and instruction.funct3 == 0b000     \
           and instruction.funct7 == 0b0100000
    
    def execute(self, state: RVState, instruction: 
    Instruction) -> None:
        rd = instruction.rd
        rs1 = instruction.rs1
        rs2 = instruction.rs2
        
        state.rf[rd] = state.rf[rs1] - state.rf[rs2]
        state.pc += 4
\end{minted}

The main distinction from \texttt{ADD} is the \texttt{funct7} field value (\texttt{0b0100000} vs \texttt{0b0000000}), which allows the same opcode to encode different operations.

\paragraph{Immediate Operations}
Immediate operations work with sign-extended 12-bit immediates. The \texttt{XORI} instruction exemplifies this category:

\begin{minted}{python}
class XorI(InstructionImpl):
    def match(self, instruction: Instruction) -> bool:
        return instruction.opcode == 0b0010011 \
           and instruction.funct3 == 0b100
    
    def execute(self, state: RVState, instruction: 
    Instruction) -> None:
        rd = instruction.rd
        rs1 = instruction.rs1
        imm_i = instruction.imm_i
        
        state.rf[rd] = state.rf[rs1] ^ imm_i
        state.pc += 4
\end{minted}

The \texttt{imm\_i} property handles sign extension, ensuring that values like \texttt{0xFFF} are treated as \texttt{-1} rather than \texttt{4095}.

\paragraph{Shift Operations}
The \texttt{SRAI} (shift right arithmetic immediate) instruction demonstrates arithmetic right shifts:

\begin{minted}{python}
class SraI(InstructionImpl):
    def match(self, instruction: Instruction) -> bool:
        return instruction.opcode == 0b0010011 \
           and instruction.funct3 == 0b101 \
           and instruction.funct7 == 0b0100000
    
    def execute(self, state: RVState, instruction: 
    Instruction) -> None:
        rd = instruction.rd
        rs1 = instruction.rs1
        # Extract 5-bit shift amount from rs2 field
        shift_amt = instruction.rs2 & 0x1F
        
        # Arithmetic right shift preserves sign bit
        state.rf[rd] = state.rf[rs1] >> shift_amt
        state.pc += 4
\end{minted}

For immediate shifts, the shift amount is encoded in the \texttt{rs2} field, with only the lower 5 bits valid for 32-bit operations.

\paragraph{Set-Less-Than Operations}
These instructions implement comparison operations that set the destination register to 1 if the condition is true, 0 otherwise. The \texttt{SLTU} instruction demonstrates unsigned comparison:

\begin{minted}{python}
class Sltu(InstructionImpl):
    def match(self, instruction: Instruction) -> bool:
        return instruction.opcode == 0b0110011 \
           and instruction.funct3 == 0b011     \
           and instruction.funct7 == 0b0000000
    
    def execute(self, state: RVState, instruction: 
    Instruction) -> None:
        rd = instruction.rd
        rs1 = instruction.rs1
        rs2 = instruction.rs2
        
        # Cast to unsigned for comparison
        result = int(
            u32(state.rf[rs1]) < u32(state.rf[rs2])
        )
        state.rf[rd] = result
        state.pc += 4
\end{minted}

The unsigned cast is needed, because the register file is defined as signed 32-bit integers, while \texttt{SLTU} operates on unsigned values.

\paragraph{Branch Instructions}
Branch instructions implement conditional control flow by modifying the program counter based on register comparisons. The \texttt{BLT} (branch if less than) instruction shows this pattern:

\begin{minted}{python}
class Blt(InstructionImpl):
    def match(self, instruction: Instruction) -> bool:
        return instruction.opcode == 0b1100011 \
           and instruction.funct3 == 0b100
    
    def execute(self, state: RVState, instruction: 
    Instruction) -> None:
        rs1 = instruction.rs1
        rs2 = instruction.rs2
        imm_b = instruction.imm_b

        if state.rf[rs1] < state.rf[rs2]:
            state.pc += imm_b  # Branch taken
        else:
            state.pc += 4     # Branch not taken
\end{minted}

The \texttt{imm\_b} property handles the complex B-type immediate encoding, reconstructing the target offset with proper sign extension.

\paragraph{Load and Store Instructions}
Memory operations require address calculation and data type conversion. The \texttt{LW} (load word) instruction demonstrates this:

\begin{minted}{python}
class Lw(InstructionImpl):
    def match(self, instruction: Instruction) -> bool:
        return instruction.opcode == 0b0000011 \
           and instruction.funct3 == 0b010
    
    def execute(self, state: RVState, instruction: 
    Instruction) -> None:
        rd = instruction.rd
        rs1 = instruction.rs1
        imm_i = instruction.imm_i
        
        # Calculate effective address
        addr = state.rf[rs1] + imm_i
        
        # Load 32-bit word from memory (little-endian)
        word_bytes = state.mem[addr:addr + 4]
        word_value = 
            np.frombuffer(word_bytes, dtype=u32)[0]
        state.rf[rd] = i32(word_value)
        state.pc += 4
\end{minted}

The implementation handles endianness conversion and ensures that loaded values are properly sign-extended when necessary.

\paragraph{Jump Instructions}
Jump operations modify control flow while saving return addresses. The \texttt{JAL} instruction shows both aspects:

\begin{minted}{python}
class Jal(InstructionImpl):
    def match(self, instruction: Instruction) -> bool:
        return instruction.opcode == 0b1101111
    
    def execute(self, state: RVState, instruction: 
    Instruction) -> None:
        rd = instruction.rd
        imm_j = instruction.imm_j
        
        # Save return address (PC + 4)
        state.rf[rd] = state.pc + 4
        
        # Jump to target address
        state.pc += imm_j
\end{minted}

\subsection{Ecall}
The \texttt{ECALL} represents the interface between user programs and the system environment. Unlike arithmetic or branch instructions that operate purely on registers and memory, \texttt{ECALL} transfers control to handle system calls.

In a hardware implementation, \texttt{ECALL} would trigger an interrupt, transferring control to the operating system. However, the VM implements system calls directly within the instruction handler to provide basic I/O functionality for demonstration programs.

The \texttt{ECALL} instruction is encoded as an I-Type instruction with specific field values:
\begin{minted}{python}
def match(self, instruction: Instruction) -> bool:
    return instruction.opcode == 0b1110011 \
       and instruction.funct3 == 0b000     \
       and instruction.funct12 == 0b000000000000
\end{minted}

The VM implements two system calls following RISC-V Linux conventions:
\begin{itemize}
    \item \textbf{System call 1}: Print integer from register \texttt{a0} to the output stream
    \item \textbf{System call 10}: Terminate program execution by setting the halt flag
\end{itemize}

The system call number is read from register \texttt{a7}, with arguments passed in registers \texttt{a0} through \texttt{a6} as needed:
\begin{minted}{python}
def execute(
    self, 
    state: RVState, 
    instruction: Instruction
) -> None:
    syscall_number = state.rf[17]  # a7 register
    if syscall_number == 10:
        state.halt = True
    elif syscall_number == 1:
        # Print integer from a0 register
        print(state.rf[10], file=self.output_stream)
    else:
        raise NotImplementedError(f"System call 
            {syscall_number} is not implemented.")
    state.pc += 4
\end{minted}

This allows the VM to execute programs that require basic output functionality, as demonstrated by the following Fibonacci example program.

\section{First Program}
With these components in place, a simple RISC-V program can be executed.
The following program is a simple example, that will generate the first 10 Fibonacci numbers and print them using the \texttt{ECALL} instruction:
\begin{minted}{gas}
.global entry
.text

entry:
    # s1 will hold the current Fibonacci number
    li s1, 1
    # s2 will hold the previous Fibonacci number
    li s2, 0
    # s3 will hold the number of 
    # Fibonacci numbers to generate
    li s3, 10 

.loop:
    # If s3 (counter) is zero, exit the loop
    beq s3, zero, .done
    # t0 = current + previous
    add t0, s1, s2       
    # Move current to previous
    mv s2, s1           
    # Move new Fibonacci number to current
    mv s1, t0           
    # Decrement the counter
    addi s3, s3, -1      
    
    # syscall number for print integer
    li a7, 1
    # Move the current Fibonacci number to a0         
    mv a0, s1
    # make the syscall          
    ecall                

    # Repeat the loop
    j .loop

.done:
    # syscall number for exit
    li a7, 10
    # make the syscall
    ecall
\end{minted}
This program compiles to the following binary (shown in hexadecimal):
\begin{minted}{text}
00100493
00000913
00a00993
02098263
012482b3
00048913
00028493
fff98993
00100893
00048513
00000073
fe1ff06f
00a00893
00000073
\end{minted}
This binary can be loaded into the VM's memory and executed.
When done, the program produces the following output:
\begin{verbatim}
1
2
3
5
8
13
21
34
55
89
\end{verbatim}
This demonstrates, that the VM is able to execute simple RISC-V programs and handle the \texttt{ECALL} instruction for input/output operations.

\subsection{Extending the VM}
The VM's modular design allows straightforward addition of new instruction sets through the extension system. This mirrors RISC-V's modular design philosophy described in section \ref{sec:modular-design}, where a base instruction set can be extended with optional functionality.

The extension system is built around three core components: the abstract \texttt{Extension} class, the \texttt{InstructionImpl} base class described in section \ref{sec:instruction-matching}, and the VM's extension loading mechanism.

\paragraph{Extension Interface}
Each extension implements the \texttt{Extension} abstract base class:
\begin{minted}{python}
class Extension(ABC):
    @abstractmethod
    def get_instruction_implementations(
        self
    ) -> list[InstructionImpl]:
        pass
\end{minted}
This simple interface requires only that extensions provide a list of their instruction implementations.

\paragraph{Concrete Extensions}
The VM includes three extensions that demonstrate different categories of functionality:

The \texttt{RV32I} extension (src/extensions/rv32i.py) implements the complete base integer instruction set described in Section 3. It provides 37 instruction implementations covering arithmetic, logical, shift, branch, jump, load/store, and system operations.

The \texttt{M} extension (src/extensions/m.py) adds integer multiplication and division operations. It implements 8 instructions: \texttt{MUL}, \texttt{MULH}, \texttt{MULHU}, \texttt{MULHSU}, \texttt{DIV}, \texttt{DIVU}, \texttt{REM}, and \texttt{REMU}. This extension includes helper functions for correct signed and unsigned arithmetic operations.

\paragraph{M Extension Implementation Details}
The M extension demonstrates how extensions handle operations that require extended precision or special arithmetic considerations. The \texttt{MUL} instruction provides a representative example:

\begin{minted}{python}
class Mul(InstructionImpl):
    def match(self, instruction: Instruction) -> bool:
        return instruction.opcode == 0b0110011 \
           and instruction.funct3 == 0b000     \
           and instruction.funct7 == 0b0000001
    
    def execute(self, state: RVState, instruction: 
    Instruction) -> None:
        rd = instruction.rd
        rs1 = instruction.rs1
        rs2 = instruction.rs2
        
        # 32-bit multiplication, keep lower 32 bits
        result = 
            (state.rf[rs1] * state.rf[rs2])
             & 0xFFFFFFFF
        state.rf[rd] = i32(result)
        state.pc += 4
\end{minted}

This instruction has the same opcode as the \texttt{ADD} instruction, but a different \texttt{funct7} field value (\texttt{0b0000001}), which identifies M extension instructions. The \texttt{MULH} instruction demonstrates the extension's handling of extended precision:

\begin{minted}{python}
class Mulh(InstructionImpl):
    def match(self, instruction: Instruction) -> bool:
        return instruction.opcode == 0b0110011 \
           and instruction.funct3 == 0b001     \
           and instruction.funct7 == 0b0000001
    
    def execute(self, state: RVState, instruction: 
    Instruction) -> None:
        rd = instruction.rd
        rs1 = instruction.rs1
        rs2 = instruction.rs2
        
        # 64-bit signed multiplication
        result = np.multiply(
            i32(state.rf[rs1]), 
            i32(state.rf[rs2]), 
            dtype=i64
        )
        # Extract upper 32 bits
        state.rf[rd] = i32(result >> 32)
        state.pc += 4
\end{minted}

This implementation uses NumPy's typed multiplication to ensure correct signed 64-bit arithmetic before extracting the upper 32 bits. The extension also handles division with proper overflow and divide-by-zero semantics as specified in the RISC-V manual.

The \texttt{ECALL} extension (src/extensions/ecall.py) handles system calls for basic I/O operations. Unlike hardware implementations that would trap to the operating system, this extension directly implements two system calls: printing integers (syscall 1) and program termination (syscall 10).

\paragraph{Extension Loading}
Extensions are loaded during VM initialization. The VM constructor accepts a list of extension objects and loads them sequentially:
\begin{minted}{python}
def load_extension(self, extension: Extension) -> None:
    ext_impls = extension
        .get_instruction_implementations()
    self.instruction_implementations.extend(ext_impls)
\end{minted}
This approach allows extensions to be combined freely, though care must be taken to avoid conflicting instructions.

\paragraph{Instruction Resolution}
During execution, the VM matches each fetched instruction against all loaded implementations. This linear search is simple but not performance-optimized. The VM ensures exactly one match per instruction, raising an exception if multiple implementations claim the same encoding.

Adding new extensions only requires implementing the \texttt{Extension} interface and providing instruction implementations that follow the \texttt{InstructionImpl} pattern shown in section \ref{sec:instruction-implementation}. No modifications to the core VM logic are necessary. 

\section{Conclusion}
This paper presents a minimal yet functional implementation of a RISC-V virtual machine written in Python, demonstrating the core principles of the RV32I instruction set architecture.

The VM's architecture achieves its primary goals of correctness and extensibility. The clear separation between the \texttt{RVState} class for processor state, the \texttt{Instruction} class for decoding functionality, and the \texttt{InstructionImpl} hierarchy for execution semantics creates a maintainable foundation. This is also shown by the extension system, which mirrors RISC-V's design philosophy by allowing optional functionality to be added without modifying core VM logic.

The practical validation through the Fibonacci program demonstrates that the VM correctly handles the essential aspects of RISC-V execution: arithmetic operations, control flow, memory access, and system calls.

While performance was deliberately deprioritized in favor of readability and educational value, the implementation provides a solid foundation for understanding RISC-V architecture and virtual machine construction. The Python implementation makes the VM accessible while maintaining correctness to the RISC-V specification.

Future work could extend the VM with additional standard extensions such as floating-point operations (F and D extensions), compressed instructions (C extension), or atomic operations (A extension).

\section*{Acknowledgments}
I acknowledge the assistance of Claude AI (Anthropic) in the preparation of this work. Specifically, Claude AI was used for proofreading and correcting spelling errors, improving the clarity and consistency of the writing style, and automating repetitive coding tasks during the development of the virtual machine implementation.

\bibliographystyle{ACM-Reference-Format}
\bibliography{references}

\end{document}
\endinput